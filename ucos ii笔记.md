![ucosii文件框图](http://i.imgur.com/Mi148RK.jpg)  
#ucos ii system
##文件结构
####上层：  
应用软件，用户代码  
####中层：   
1. 与处理器无关代码  
![与处理器类型无关的代码](http://i.imgur.com/gRRD1mK.jpg)  
2. 与应用程序相关配置文件    
![与应用程序有关](http://i.imgur.com/EXWlGwx.jpg)     
3. 与处理器有关代码    
![与处理器有关的代码](http://i.imgur.com/cYTFXjB.jpg)   
 
####下层：
硬件(cpu,interupt,timer,gpio,iis...)  

##内核结构  
####核心功能函数  
```
OS_ENTER_CRITICAL()/OS_EXIT_CRITICAL()  开中断/关中断  
OSInit()  
OSStart()  
OSIntEnter()  
OSIntExit()  
OSSchedLock()/Unlock()  
OSVersion()  
```
####重要结构体    
####临界段    
处理器处理临界代码都必须先关中断，再处理临界代码，然后再开中断。关中断时间对实时系统的实时响应很重要。所以是实时系统的一个很重要的指标。uCOS使用两个宏（在OS_CPU.h中定义。注：没个CPU都有自己的OS_CPU.h）。这两个宏分别为OS_ENTER_CRITICAL()和OS_EXIT_CRITICAL()关闭中断和打开中断. 列:  

```      
void function(void)

{  

	OS_ENTER_CRITICAL(); //关闭中断   

    /*uCOS II 临界代码段*/  

    OS_EXIT_CRITICAL(); //打开中断  
}
```  
#####注:在ODTimeDel()之类的函数调用的时候不能关闭中断，不然应用程序会死机.  
###任务

> 通常任务是一个无限循环。函数没有返回值。任务完成以后可以自我删除。(注意：删除不是任务代码删除了，只是这个任务不会再执行了；即使调用了OSTaskDel()这个任务也不会有返回值).    

####任务创建: 
	可以使用`OSTaskCreat()`或者`OSTaskCreatExt()`创建.uCOS II 可以管理的任务可以达到64个，但是建议不要使用前四个优先级的任务和后四个优先级的任务.   
     
####任务状态：  

	1. 睡眠: 驻留在ROM或者RAM中，系统还没有管理，只有通过`OSTaskCreat()`或`OSCreatExt()`创建之后才能使得系统管理任务.  
	2. 就绪: 任务一旦建立就进入了就绪态，等待运行.  
	3. 等待: 可以调用`OSTimeDel()`或者`OSTimeDlyHMSM()`使得任务进入等待状态。一直等待函数中定义的延时时间到了，这两个函数会强制执行任务转换，让下一个优先级更高的任务进入就绪态的任务运行.  
	4. 运行: 当前任务正在执行.
	5. 中断: 当前正在执行的任务被中断，进入中断服务态，响应中断时该任务被挂起。中断服务子程序占有了CPU的使用权.  


####任务控制块(TCB)：
	重要的数据结构,一旦任务建立了，任务控制块OS­­_TCB将被赋值，ucosii用它保存任务的状态，用来恢复任务. 任务建立的时候，OS­­_TCBs就被初始化了. 关键的结构体变量:
		1. OSTCBStkPtr: 当前任务栈顶的指针.是OS_TCB数据结构中唯一的一个能用汇编语言来处置的变量（在任务切换段的代码中）,把OSTCBStkPtr放在数据结构的最前面，使得从汇编语言中处理这个变量时较为容易.  
		2. OSTCBExtPtr: 指向用户定义的任务控制块扩展.用户可以扩展任务控制块而不必修改μC/OS-Ⅱ的源代码.  
		3. OSTCBStkBottom: 指向任务栈底的指针.函数`OSTaskStkChk()`(用于堆栈检验)要用到变量OSTCBStkBottom,在运行中检验栈空间的使用情况。用户可以用它来确定任务实际需要的栈空间.这个功能只有当用户在任务建立时允许使用`OSTaskCreateExt()`函数时才能实现。这就要求用户将`OS_TASK_CREATE_EXT_EN`设为1以便允许该功能. 
		4. OSTCBStkSize: 存有栈中可容纳的指针元数目，而不是用字节表示的栈容量总数.

####任务就绪表：  
	每个就绪的任务都放在任务就绪表中。就绪表中有两个变量，OSRdyGrp和OSRdyTbl[],在OSRdyGrp中任务按照优先级分组，8个任务为一组。OSRdyGrp中的每位表示8组任务中每一组是否有进入就绪态的任务,任务就绪，OSRdyTbl[]中相应元素中的相应位也被置1.OSRdyTbl[]数组有多大取决于OS_LOWSET_PRIO.当应用程序的数目比较少的时候可以降低OS_LOWSET_PRIO，可以降低系统对RAM（数据空间）的需求. 
			
####任务调度:  
	根据任务优先级,UCOS总是让就绪表中任务优先级最高的任务先执行.
	任务的调度由函数：OSSched()完成。中断级的调用由另一个函数：OSIntExt()完成。  

####任务切换:  
	任务调度器决定哪个任务该运行了，然后由IS_TASK_SW()函数做任务切换.OS_TASK_SW()是一个宏调用。含有处理器的软中断指令.
 
####注:UCOSII只有任务的概念，目前没有进程的概念，那任务和进程的区别是什么，这也是UCOSII这么小的一个原因，还有任务之间的内存分配要划分好空间，否则某个任务如果写了另外一个任务的空间，那么就有可能导致系统崩溃，但像linux有了进程概念，就不会出现这种情况，这些都是要逐渐了解的.  可信度?

###调度
上锁，开锁
###空闲任务
优先级最低，必须存在
###统计任务
优先级次低，选择  
每秒运行一次计算CPU利用率，精度1%。
###中断
###时钟节拍
提供周期性信号源，用于时间延迟和确认超时。
###流程
    `
	OSInit();//ucos的初始化,空闲任务，统计任务，系统变量及数据结构         
	OSStart();//ucos的启动,必须建立一个任物  
	`
##任务管理
##时间管理
##事件管理
##信号量管理
##消息管理
##内存管理
##ucos ii的移植
###ucos ii给实时系统开发提供一个简易的框架，其实现基本的系统管理功能。
###开发者需要做的是根据自己的平台修改和剪裁。
###需要设计中修改的如处理器的位数，开中断和关中断实现等。
###调通基本的系统，就可以在上面根据需要开发更多的功能。
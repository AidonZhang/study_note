
###1.非局部跳转语句---setjmp和longjmp函数
特点  
	非togo语句在函数内实施跳转,而是在栈上跳过若干调用帧,返回到当前函数调用路径上的某一语句.  
	头文件包含#include<setjmp.h>.  
    `Void longjmp(jmp_buf env,int val);`  
    返回值：若直接调用则返回0，若从longjmp调用返回则返回非0值  
	注: setjmp参数evn的类型是一个特殊的类型jmp_buf,这一数据类型是某种形式的数组，其中存放在调用longjmp时能用来恢复栈状态的所有信息.因为需要在另一个函数中引用env变量，所以规范的处理方式是将env变量定义为全局变量。  
	  
使用方法  
	在希望返回到的位置调用setjmp, 当检查到一个错误时,则以两个参数调用longjmp函数,第一个就是在调用setjmp时所用的env，第二个参数是具有非0值的val，它将成为从setjmp处返回的值.使用第二个参数的原因是对于一个setjmp可以有多个longjmp。  
    注:在使用longjmp跳转到setjmp中时，程序主动的退出了！相当于抛出一个异常退出！  
使用setjmp和longjmp要注意以下几点:
	
1. setjmp与longjmp结合使用时，它们必须有严格的先后执行顺序，也即先调用setjmp函数，之后再调用longjmp函数，以恢复到先前被保存的“程序执行点”。
2. 不要假设寄存器类型的变量将总会保持不变.在调用longjmp之后，通过setjmp所返回的控制流中，程序中寄存器类型的变量将不会被恢复。 寄存器类型的变量一般都是临时变量，在C语言中，通过register定义，或直接嵌入汇编代码的程序。
3.  longjmp必须在setjmp调用之后，而且longjmp必须在setjmp的作用域之内.

###2.Big-Endian大端模式和Little-Endian小端模式 
定义  
1. Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。  
2. Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。  
3. 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序.
4. 高/低字节定义:在十进制中我们都说靠左边的是高位，靠右边的是低位，在其他进制也是如此。就拿 0x12345678来说，从高位到低位的字节依次是0x12、0x34、0x56和0x78。  
例子分析  

`unsigned int value = 0x12345678 ` 

1.Big-Endian: 低地址存放高位  
|- 栈底 （高地址）|||
|---------------   
|- buf[3] |- (0x78) |- 低位|    
|- buf[2] |- (0x56) |  
|- buf[1] |- (0x34) |  
|- buf[0] |- (0x12) |- 高位|  
|- **栈顶 （低地址）**|||  

2.Little-Endian: 低地址存放低位  
|- 栈底 （高地址）|||
|---------------  
|- buf[3] |- (0x12) |- 高位  
|- buf[2] |- (0x34)  
|- buf[1] |- (0x56)  
|- buf[0] |- (0x78) |- 低位  
|- **栈 顶 （低地址）**|||

在Little-endian模式CPU内存中的存放方式(假设从地址0x4000开始存放)  
  
|内存地址  |   0x4000  |   0x4001  |   0x4002  |  0x4003 |     
|---------|-----------|-----------|-----------|---------|  
|存放内容  |   0x78    |   0x56    |   0x34    |  0x12   |    

在Big- endian模式CPU内存中的存放方式则为    

|内存地址  |   0x4000  |   0x4001  |   0x4002  |  0x4003 |     
|---------|-----------|-----------|-----------|---------|    
|存放内容  |   0x12    |   0x34    |   0x56    |   0x78  |   

注意：通常我们说的主机序（Host Order）就是遵循Little-Endian规则。所以当两台主机之间要通过TCP/IP协议进行通信的时候就需要调用相应的函数进行主机序 （Little-Endian）和网络序（Big-Endian）的转换。  
检查CPU是大端还是小端:

    int checkCPU(void)  
    {  
    	union  
    	{  
    		int a;  
    		char b;  
    	}c;  
    	c.a = 1;  
    	return (c.b == 1);  
    }

5/27/2016 9:46:23 AM   
###3.AT&T汇编指令学习(GCC)  
1. 寄存器命名原则:
	相比inter语法,AT&T语法格式要求所有的寄存器都必须加上取值符"%".  
2. 操作码命令格式:
	1. 源/目的操作数顺序:  
		Intel语法格式中命令表示格式为:"opcode dest, src"; "操作码 目标, 源"  
		AT&T语法格式表示为:"opcode src, dest"; "操作码 源, 目标"  

	2. 操作数长度标识:  
		在AT&T语法中,通过在指令后添加后缀来指明该指令运算对象的尺寸.  
		后缀 'b' 指明运算对象是一个字节(byte)   
		后缀 'w' 指明运算对象是一个字(word)   
		后缀 'l' 指明运算对象是一个双字(long)  
		Intel语法中指令'mov'在AT&T语法必须根据运算对象的实际情况写成:'movb','movw'或'movl'。  
        注:若在AT&T中省略这些后缀,GAS将通过使用的寄存器大小来猜测指令的操作数长度.      
	3. 另外,  
		'FAR'不是GAS的关键字,因此对far的call或jmp指令须加前缀 'l', 'far call'要写成 'lcall' , 'far jmp' 要写成 'ljmp' , 'ret far' 写成 'lret'。
3. 常数/立即数的格式:   
	在AT&T语法中对立即数,须在其前加前缀 $ 来指明,而Inter语法则不需要。  
	另外, 在常数前也必须加一个前缀字符 * ,而Inter语法则也是不需要的。  
4. 内存寻址方式:  
	在Intel语法中,使用下面格式来表示存储器寻址方式:  
		`SECTION:[BASE + INDEX*SCALE + DISP];`段:[基地址+变址*比例因子+偏移量]  
		BASE是基地址索引寄存器(可以是任一通用寄存器),  
		INDEX是变址寄存器(除ESP外的任一通用寄存器),  
		SCALE是变址寄存器的比例常数,  
		DISP是基址/变址寄存器的位移量。  
    AT&T语法则使用不同的格式来表示寻址方式:  
		`SECTION:DISP(BASE, INDEX, SCALE);`段:偏移量(基地址,变址,比例因子)  
5. 标号 & 标识符:  
	所有的标号必须以一个字母,点或下划线开始,标号后加一个冒号表示标号的结束。  
	局部标号使用数字0-9后跟一个冒号,使用局部标号时要在数字后跟一个字符'b'(向后引用)或字符'f'(向前引用)。因为只能使用数字0-9作为局部标号名,所以最多只能定义10个局部标号.一个标识符能给它赋于一个值。(如:'TRUE=1', 或者使用 .set 或 .equ 指令)。  
6. 基本的行内汇编格式:   
		`asm("statements");`  
	例如：asm("nop"); asm("movl %eax,%ebx");   
	asm　和　__asm__是完全一样的.  
	如果有多行汇编，则每一行都要加上　"\n\t"
7. 扩展的行内汇编格式:  
		`asm ( "statements" : output_regs : input_regs : clobbered_regs);`  
	冒号后的语句指明输入，输出和被改变的寄存器．   
5/31/2016 3:31:01 PM 
###4.内存对齐
1. 为何要内存对齐  
	1. **平台原因(移植原因)**：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
	2. **性能原因**：经过内存对齐后，CPU的内存访问速度大大提升。  
2. 内存对齐的规则  
	许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k(通常它为4或8)的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。当一种类型S的对齐模数与另一种类型T的对齐模数的比值是大于1的整数，我们就称类型S的对齐要求比T强(严格)，而称T比S弱(宽松)。这种强制的要求一来简化了处理器与内存之间传输系统的设计，二来可以提升读取数据的速度。  
	比如这么一种处理器，它每次读写内存的时候都从某个8倍数的地址开始，一次读出或写入8个字节的数据，假如软件能保证double类型的数据都从8倍数地址开始，那么读或写一个double类型数据就只需要一次内存操作。否则，我们就可能需要两次内存操作才能完成这个动作，因为数据或许恰好横跨在两个符合对齐要求的8字节内存块上。某些处理器在数据不满足对齐要求的情况下可能会出错.  
	但是Intel的IA32架构的处理器则不管数据是否对齐都能正确工作。不过Intel奉劝大家，如果想提升性能，那么所有的程序数据都应该尽可能地对齐。  
	
	1. Win32平台下的微软C编译器(cl.exe for 80x86)在默认情况下采用如下的对齐规则:   
	**任何基本数据类型T的对齐模数就是T的大小，即sizeof(T)。比如对于double类型8字节)，就要求该类型数据的地址总是8的倍数，而char类型数据(1字节)则可以从任何一个地址开始。** 
	2. Linux下的GCC对齐规则:  
	**char类型数据(1字节)起始位置任意,任何2字节大小的数据类型(比如short)的对齐模数是2，而其它所有超过2字节的数据类型(比如long,double)都以4为对齐模数。**



 
	

